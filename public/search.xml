<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用synopsys uvmgen快速生成uvm环境</title>
      <link href="/2019/04/19/%E4%BD%BF%E7%94%A8synopsys%20uvmgen%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90uvm%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/04/19/%E4%BD%BF%E7%94%A8synopsys%20uvmgen%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90uvm%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="通过vcs-uvmgen模板生成UVM环境"><a href="#通过vcs-uvmgen模板生成UVM环境" class="headerlink" title="通过vcs uvmgen模板生成UVM环境"></a>通过vcs uvmgen模板生成UVM环境</h3><ul><li>命令行：<br><img src="/2019/04/19/使用synopsys uvmgen快速生成uvm环境/uvmgen1.png" alt="uvmgen-cmd"></li><li>树形结构：<br><img src="/2019/04/19/使用synopsys uvmgen快速生成uvm环境/uvmgen2.png" alt="uvmgen-tree"></li><li>代码样例：<br><img src="/2019/04/19/使用synopsys uvmgen快速生成uvm环境/uvmgen3.png" alt="uvmgen-demo"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 验证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UVM </tag>
            
            <tag> EDA </tag>
            
            <tag> synopsys </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用脚本收集</title>
      <link href="/2019/04/19/%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E6%94%B6%E9%9B%86/"/>
      <url>/2019/04/19/%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="常用脚本收集"><a href="#常用脚本收集" class="headerlink" title="常用脚本收集"></a>常用脚本收集</h3><ul><li><p>Sed</p><ul><li><p>直接对文本文件进行行替代操作</p><figure class="hljs highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sed -<span class="hljs-selector-tag">i</span> <span class="hljs-string">'s/原字符串/新字符串/'</span> file<br>sed -<span class="hljs-selector-tag">i</span> <span class="hljs-string">'s/原字符串/新字符串/g'</span> file<br></code></pre></td></tr></table></figure></li><li><p>去掉 “行首” 带“@”的首字母@的行</p><figure class="hljs highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sed -<span class="hljs-selector-tag">i</span> <span class="hljs-string">'s/^@//'</span> file<br></code></pre></td></tr></table></figure></li><li><p>在含有特定字符串的行前插入新行</p><figure class="hljs highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sed -<span class="hljs-selector-tag">i</span> <span class="hljs-string">'/特定字符串/i 新行字符串'</span> file<br></code></pre></td></tr></table></figure></li><li><p>在含有特定字符串的行后插入新行</p><figure class="hljs highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sed -<span class="hljs-selector-tag">i</span> <span class="hljs-string">'/特定字符串/a 新行字符串'</span> file<br></code></pre></td></tr></table></figure></li><li><p>删除含有特定字符串的行</p><figure class="hljs highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sed -<span class="hljs-selector-tag">i</span> <span class="hljs-string">'/字符串/d'</span> file<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li>python</li></ul><hr><ul><li>Perl</li></ul><hr><ul><li><p>Shell</p><ul><li><p>列出所有目录使用量，并按大小排序。</p><figure class="hljs highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">ls</span>|xargs du -<span class="hljs-keyword">h</span>|<span class="hljs-keyword">sort</span> -rn <br>#不递归下级目录使用du -<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure></li><li><p>查看文件排除以#开关和空白行。</p><figure class="hljs highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">egrep</span> -v <span class="hljs-string">"^#|^$"</span>  filename<br>sed <span class="hljs-string">'/#.*$/d; /^ *$/d'</span><br></code></pre></td></tr></table></figure></li><li><p>查删除空格和空行。</p><figure class="hljs highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">sed</span> <span class="hljs-string">'/^$/d'</span> filename <span class="hljs-comment">#删除空行</span><br>sed <span class="hljs-string">'s/ //g'</span> filename<br>sed <span class="hljs-string">'s/[[:space:]]//g'</span> filename<br></code></pre></td></tr></table></figure></li><li><p>删除#后的注释。</p><figure class="hljs highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sed -<span class="hljs-selector-tag">i</span> <span class="hljs-string">'s/#.*$//g'</span> filename<br></code></pre></td></tr></table></figure></li><li><p>删除空文件。</p><figure class="hljs highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-built_in">find</span> / -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">size</span> <span class="hljs-number">0</span> -<span class="hljs-built_in">exec</span> rm -rf &#123;&#125; \;<br></code></pre></td></tr></table></figure></li><li><p>查找进程pid并kill。</p><figure class="hljs highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">pgrep nginx<span class="hljs-string">|xargs kill </span><br>pidof nginx<span class="hljs-string">|xargs kill</span><br></code></pre></td></tr></table></figure></li><li><p>取当前IP地址。</p><figure class="hljs highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">ifconfig</span> |awk -F<span class="hljs-string">"[ ]+|[:]"</span> <span class="hljs-string">'NR==2 &#123;print <span class="hljs-variable">$4</span>&#125;'</span><br></code></pre></td></tr></table></figure></li><li><p>shell下新建文件夹并进入，以下加入bashrc。</p><figure class="hljs highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">mkcd</span> ( )&#123;<br>   <span class="hljs-attribute">mkdir</span> <span class="hljs-variable">$1</span><br>       cd <span class="hljs-variable">$1</span><br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>Kill整个进程树。</p><figure class="hljs highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">pstree -ap <span class="hljs-number">10277</span>|grep -oP '[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;'|xargs kill <span class="hljs-number">-9</span><br></code></pre></td></tr></table></figure></li><li><p>目录中大量文件删除。</p><figure class="hljs highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">ls</span> | xargs <span class="hljs-keyword">rm</span><br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer-Sequence结构图</title>
      <link href="/2019/04/19/Layer-Sequence%E7%BB%93%E6%9E%84%E5%9B%BE/"/>
      <url>/2019/04/19/Layer-Sequence%E7%BB%93%E6%9E%84%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="UVM-Layer-Sequence结构图"><a href="#UVM-Layer-Sequence结构图" class="headerlink" title="UVM Layer Sequence结构图"></a>UVM Layer Sequence结构图</h3><p><img src="/2019/04/19/Layer-Sequence结构图/Layer-Sequence结构图.png" alt="Layer-Sequence结构图"></p><font color="blue"><br><br> 1.可以1:1，1：N，N:N进行堆叠。<br><br> 2.堆叠指针必须指向对应的sequencer。<br><br></font>]]></content>
      
      
      <categories>
          
          <category> 验证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UVM </tag>
            
            <tag> SystemVerilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 查找指定名称的进程并显示进程详细信息</title>
      <link href="/2019/04/19/Linux%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/19/Linux%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="给定一个进程名称特征串，查找所有匹配该进程名称的进程的详细信息。"><a href="#给定一个进程名称特征串，查找所有匹配该进程名称的进程的详细信息。" class="headerlink" title="给定一个进程名称特征串，查找所有匹配该进程名称的进程的详细信息。"></a>给定一个进程名称特征串，查找所有匹配该进程名称的进程的详细信息。</h3><font color="blue"><p>(1) 先用pgrep [str] 命令进行模糊匹配，找到匹配该特征串的进程ID；</p><p>(2) 其次根据进程ID显示指定的进程信息，ps –pid [pid]；</p><p>(3) 因为查找出来的进程ID需要被作为参数传递给ps命令，故使用xargs命令，通过管道符号连接；</p><p>(4) 最后显示进程详细信息，需要加上-u参数。</p><p>最终命令形如:</p><p>pgrep ncsim | xargs ps -u –pid<br></p></font>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VCS Crash如何定位？</title>
      <link href="/2019/04/18/VCS-Crash%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%EF%BC%9F/"/>
      <url>/2019/04/18/VCS-Crash%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="~友情QQ红包，发送密码~">    <label for="pass">~友情QQ红包，发送密码~</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19kbH1qk+ZlDZKkLeSUlBOxoAlhby3ZocDV9iU0CtZq9KuLumryrfpgDEb/cNs59ZsDXjqg/7jHd9OWdmYEHQW3qrBlb4X5wiGlZnBFr6IXYfmfh7YmB9+mMAnNTYNnxsKUayDI4AJdZ6Wi/b3LC+sht8vGB4fkmSyQgGikuKTzDYqGEf8q52q7mnvnN62e22qieX5IDOuEAnx4AwgTRASl9WILOeuJDXrgcBAIfp2vtGHebppgSpbDVl5pH5PUNMzEcDrkKpiYdbAH6oSxlLqwFnoXinb/SBhNe4Tnfn0pwB0jiJnrVFnggEy2eQSiG3J2oD9myfLVFlxO1lF+0VWh7FibFAqdxWw7rkP8iu+LHmubvWn80jORTWANlgiwXMN2y6WTwTgXmL+0JAiHQsMOuQV+KUjCr7VAeDWh35jh9xLVqwqjD5w+sPiuuezAEjFFVd6PjNyMqho8DfojZKDFFld8RdtLWICMDjMXjk1LdmrAfRQJ5cZ3pcLQbMCjqrFFHHtBRIuNf0hcUExM6cI90B4kjHryYdAm5nuG3r0S36n7hNf4AgGi1lOJf8txX1zCtI87uaGMiQ7/EIoerGfR2zU+i/TXqpkU9TO1MMvd2JGUkJpJot/phs/MRVz6vQAnajBJ3otTjtHpgzfG610RZF6SPZ0F86fPaQLyZ5hbNsh12UTIYfw7Yth6MK4+cFTWEF9Uk3wHej2wabSx77OeAVjd3CMqguvpzCZl8/uYm+wHdxCEhzRnNDK0eow2j5RC5Am9mxhjfQVue9aZtwcvU9UYT+iFssB1yHbVSgguCh8kn/aH04wbKpXRu9LhGf+PH0QZvmkx8tX2NDFULPCFycjO4GgH5GDo/8pIgvFg1gDjyVM0M7Yv</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 验证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EDA </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clocking块为什么能保证race free?</title>
      <link href="/2019/04/18/clocking%E5%9D%97%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E4%BF%9D%E8%AF%81race-free/"/>
      <url>/2019/04/18/clocking%E5%9D%97%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E4%BF%9D%E8%AF%81race-free/</url>
      
        <content type="html"><![CDATA[<h2 id="为啥要推荐使用clocking块？"><a href="#为啥要推荐使用clocking块？" class="headerlink" title="为啥要推荐使用clocking块？"></a>为啥要推荐使用clocking块？</h2><font color="red"><br>代码例子：<br><pre name="code" class="systemverilog"><br><br>clocking cb @(negedge clk);<br>  input v;<br>endclocking<br><br>always @(cb) $display(cb.v);//采样old值<br><br>always @(negedge clk) $display(cb.v);//采样old or new值和仿真器相关。<br><br></pre><br><br>主要原因是clocking块中默认为1step采样，在clk下降沿发生时（@(cb)触发），数据已经采样了。<br>而第二条always语句直接(@(negedge clk))和（@(cb)）并发，所以就有race glitch。<br><br></font> ]]></content>
      
      
      <categories>
          
          <category> 验证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVM寄存器模型中soft和hard reset有什么区别？</title>
      <link href="/2019/04/18/UVM%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E4%B8%ADsoft%E5%92%8Chard-reset%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2019/04/18/UVM%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E4%B8%ADsoft%E5%92%8Chard-reset%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Kind-“HARD”-or-“SOFT”"><a href="#1-Kind-“HARD”-or-“SOFT”" class="headerlink" title="1.Kind = “HARD” or “SOFT”"></a>1.Kind = “HARD” or “SOFT”</h2><p>寄存器模型中复位操作这个到底有什么作用呢？源码如下：</p><font color="red"><br>代码例子：<br><pre name="code" class="systemverilog"><br>function void uvm_reg_xxx::reset(string kind = “HARD”);<br>    if (!m_reset.exists(kind))<br>          return;<br>    m_mirrored = m_reset[kind];<br>    m_desired  = m_mirrored;<br>    value      = m_mirrored;<br>    if (kind == “HARD”)<br>        m_written  = 0;<br>endfunction: reset<br></pre><br></font><br><font color="blue"><br>其实是作为特别处理用的，如果所有的寄存器都只有一个复位的时候默认一个HARD值统一复位。<br>如果某个寄存器需要特殊的复位，则可以重写该类中的reset（…）方法：<br>代码例子：<br><pre name="code" class="systemverilog"><br>class some_reg extends uvm_reg;<br>    …<br>    function void reset(string kind = “HARD”);<br>        if (kind != “SOFT”)<br>            super.reset(kind);<br>    endfunction<br><br>endclass<br></pre><br></font> ]]></content>
      
      
      <categories>
          
          <category> 验证 </category>
          
          <category> UVM-RAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UVM </tag>
            
            <tag> SystemVerilog </tag>
            
            <tag> RAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVM-Register-Model</title>
      <link href="/2019/04/17/UVM-Register-Model/"/>
      <url>/2019/04/17/UVM-Register-Model/</url>
      
        <content type="html"><![CDATA[<h1 id="1-UVM寄存器模型相关操作引起的一些关键变化"><a href="#1-UVM寄存器模型相关操作引起的一些关键变化" class="headerlink" title="1.UVM寄存器模型相关操作引起的一些关键变化"></a>1.UVM寄存器模型相关操作引起的一些关键变化</h1><h1 id="缩写词"><a href="#缩写词" class="headerlink" title="缩写词"></a><strong>缩写词</strong></h1><p>UMV –  Update Main Variable,<br>UMrV – Update Mirror Variable,<br>AP – Auto predict<br>RDR – Read DUT Register,<br>UDR – Update DUT Register,<br>RMV – Read Main Variable<br>FD – frontdoor,<br>BD – Backdoor,   <em>  – check if UVM_CHEK is used,   NA – Not Applicable</em></p><p><img src="https://github.com/275244143/picBed/blob/master/uvm-reg-access.jpg?raw=true" alt></p>]]></content>
      
      
      <categories>
          
          <category> 验证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UVM </tag>
            
            <tag> SystemVerilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式验证</title>
      <link href="/2019/04/17/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81/"/>
      <url>/2019/04/17/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么时候需要使用形式验证（Formal-Verification：FV）"><a href="#1-什么时候需要使用形式验证（Formal-Verification：FV）" class="headerlink" title="1.什么时候需要使用形式验证（Formal Verification：FV）"></a>1.什么时候需要使用形式验证（Formal Verification：FV）</h2><p>1.1 <strong>FV FOR COMPLETE COVERAGE：</strong></p><pre><code>When you want to get complete coverage of design behaviors, consider using FV as your primary validation method.注释：    当你需要100%覆盖功能时。例如：32bit * 32bit 乘法器，需要每个数字都要进行cover。</code></pre><p>1.2 <strong>FV for Bug Hunting：</strong></p><pre><code>When you have a design with nontrivial logic and are worried that you will not be able to get sufficient coverage with simulation tests, think about FV as a supplement to simulation.注释：    担心无法获得足够的仿真测试覆盖时，可以考虑将FV作为补充，增强tapout信心。</code></pre><p>1.3 <strong>FV for Exploring Designs：</strong></p><pre><code>When you have a design where you can easily specify interesting states or outputs, but it is difficult or time-consuming to specify the sequence of inputs needed to get there, think about using FV.注释：    虽然设计简单，如一些MUX组合，但很难或费时地指定需要的输入序列，可以考虑使用FV。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 验证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
            <tag> ABV </tag>
            
            <tag> FV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ红包打赏,验证技术微信公众号，扫码即可，你的支持，就是技术的不断前进！</title>
      <link href="/2019/04/16/QQ%E7%BA%A2%E5%8C%85%E6%89%93%E8%B5%8F,%E9%AA%8C%E8%AF%81%E6%8A%80%E6%9C%AF%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%8C%E6%89%AB%E7%A0%81%E5%8D%B3%E5%8F%AF%EF%BC%8C%E4%BD%A0%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%8A%80%E6%9C%AF%E7%9A%84%E4%B8%8D%E6%96%AD%E5%89%8D%E8%BF%9B%EF%BC%81/"/>
      <url>/2019/04/16/QQ%E7%BA%A2%E5%8C%85%E6%89%93%E8%B5%8F,%E9%AA%8C%E8%AF%81%E6%8A%80%E6%9C%AF%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%8C%E6%89%AB%E7%A0%81%E5%8D%B3%E5%8F%AF%EF%BC%8C%E4%BD%A0%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%8A%80%E6%9C%AF%E7%9A%84%E4%B8%8D%E6%96%AD%E5%89%8D%E8%BF%9B%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h1 id="谢谢打赏"><a href="#谢谢打赏" class="headerlink" title="谢谢打赏"></a>谢谢打赏</h1><p><img src="https://github.com/275244143/picBed/blob/master/QQ%E5%9B%BE%E7%89%8720190416222833.png?raw=true" alt="QQ"></p><h1 id="验证技术公众号（Ricky友情支持）"><a href="#验证技术公众号（Ricky友情支持）" class="headerlink" title="验证技术公众号（Ricky友情支持）"></a>验证技术公众号（Ricky友情支持）</h1><p><img src="https://github.com/275244143/picBed/blob/master/QQ%E5%9B%BE%E7%89%8720190416224606.jpg?raw=true" alt="WEBCHAT"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemVerilog语法释义</title>
      <link href="/2019/04/16/SystemVerilog%E8%AF%AD%E6%B3%95%E9%87%8A%E4%B9%89/"/>
      <url>/2019/04/16/SystemVerilog%E8%AF%AD%E6%B3%95%E9%87%8A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-浮点数转换"><a href="#1-浮点数转换" class="headerlink" title="1.浮点数转换"></a>1.浮点数转换</h2><h3 id="ieee1800-2017解释："><a href="#ieee1800-2017解释：" class="headerlink" title="ieee1800-2017解释："></a>ieee1800-2017解释：</h3><pre><code>Real numbers shall be converted to integers by rounding the real number to the nearest integer, rather than by truncating it. Implicit conversion shall take place when a real number is assigned to an integer. If the fractional part of the real number is exactly 0.5, it shall be rounded away from zero.</code></pre><font color="blue"><br>代码例子：<br><pre name="code" class="systemverilog"><br>int x_int;<br>x_int = 2.4;//x_int –&gt; 2<br>x_int = 2.5;//x_int –&gt; 3<br>x_int = int’(2.5);//x_int –&gt; 2<br></pre><br></font> <h2 id="2-数据比特位快速反转"><a href="#2-数据比特位快速反转" class="headerlink" title="2.数据比特位快速反转"></a>2.数据比特位快速反转</h2><font color="blue"><br>代码例子：<br><pre name="code" class="systemverilog"><br>bit [15:0] x = 16’b0000_1011_0000_0011;<br>x= { &lt;&lt; {x} }; //x –&gt; 16’b1100_0000_1101_0000;<br></pre><br></font> <h2 id="3-super-super如何解决无法支持问题？"><a href="#3-super-super如何解决无法支持问题？" class="headerlink" title="3.super.super如何解决无法支持问题？"></a>3.super.super如何解决无法支持问题？</h2><font color="blue"><br>代码例子：<br><pre name="code" class="systemverilog"><br>module tb;<br><br>class A;<br>    virtual function void test();<br>        $display(“%m”);<br>    endfunction<br>endclass<br><br>class B extends A;<br>    virtual function void test();<br>        $display(“%m”);<br>    endfunction<br>endclass<br><br>class C extends B;<br>    virtual function void test();<br>        super.test();//Call B test()<br>        //super.super.test();//error!Can not support！<br>        //use follow<br>        A::test();//Call A test()<br>        $display(“%m”);<br>    endfunction<br>endclass<br><br>initial begin<br>    C cinst = new();<br>    cinst.test();<br>end<br><br>endmodule<br><br>仿真执行结果：<br>tb.B.test<br>tb.A.test<br>tb.C.test<br><br></pre><br></font> ]]></content>
      
      
      <categories>
          
          <category> 验证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UVM </tag>
            
            <tag> SystemVerilog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
